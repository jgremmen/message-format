package de.sayayi.lib.message.internal.pack;

import de.sayayi.lib.message.MessageSupport;
import de.sayayi.lib.message.MessageSupport.ConfigurableMessageSupport;
import de.sayayi.lib.message.MessageSupportFactory;
import de.sayayi.lib.message.adopter.PropertiesAdopter;
import de.sayayi.lib.message.formatter.DefaultFormatterService;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.springframework.util.MimeType;

import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.Properties;
import java.util.stream.Stream;

import static de.sayayi.lib.message.MessageFactory.NO_CACHE_INSTANCE;
import static java.lang.Boolean.parseBoolean;
import static java.lang.Integer.parseInt;
import static java.nio.charset.StandardCharsets.ISO_8859_1;
import static java.nio.file.Files.*;
import static java.util.Objects.requireNonNull;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.util.MimeTypeUtils.parseMimeType;


/**
 * @author Jeroen Gremmen
 * @since 0.9.1
 */
@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Message pack backward compatibility")
class PackCompatibilityTest
{
  private static final MimeType MIME_TYPE = new MimeType("application", "x-message-format-pack");


  private static MessageSupport MESSAGE_SUPPORT;


  @BeforeAll
  static void init() throws IOException
  {
    MESSAGE_SUPPORT = MessageSupportFactory.create(new DefaultFormatterService(), NO_CACHE_INSTANCE);

    var properties = new Properties();
    var adopter = new PropertiesAdopter((ConfigurableMessageSupport)MESSAGE_SUPPORT);

    properties.load(
        new InputStreamReader(newInputStream(Path.of("src/test/resources/template.properties")), ISO_8859_1));
    adopter.adoptTemplates(properties);

    properties.clear();
    properties.load(
        new InputStreamReader(newInputStream(Path.of("src/test/resources/message.properties")), ISO_8859_1));
    adopter.adopt(properties);
  }


  private static Stream<Arguments> versionParameters()
  {
    return Stream.of(
        Arguments.of("0.20.0", 1, 8, 2),
        Arguments.of("0.20.1", 2, 9, 2)
    );
  }


  @DisplayName("Import message packs")
  @ParameterizedTest(name = "Generated by version {0}")
  @MethodSource("versionParameters")
  void importMessagePack(String libraryVersion, int expectedVersion, int messageCount, int templateCount)
      throws IOException
  {
    var messagePackPath = Path.of("src/test/resources/messages-" + libraryVersion + ".mfp");
    var cms = MessageSupportFactory.create(new DefaultFormatterService(), NO_CACHE_INSTANCE);

    // mime type
    var mimeType = parseMimeType(probeContentType(messagePackPath));
    assertTrue(mimeType.isCompatibleWith(MIME_TYPE));
    assertEquals(expectedVersion, parseInt(requireNonNull(mimeType.getParameter("version"))));
    assertTrue(parseBoolean(requireNonNull(mimeType.getParameter("compress"))));

    // import messages/templates
    cms.importMessages(newInputStream(messagePackPath));

    var messageAccessor = cms.getMessageAccessor();
    var expectedMessageAccessor = MESSAGE_SUPPORT.getMessageAccessor();

    assertEquals(messageCount, messageAccessor.getMessageCodes().size());
    assertEquals(templateCount, messageAccessor.getTemplateNames().size());

    // check templates
    for(var templateName: messageAccessor.getTemplateNames())
    {
      assertTrue(
          expectedMessageAccessor.getTemplateByName(templateName).isSame(messageAccessor.getTemplateByName(templateName)),
          "Template mismatch for '" + templateName + "'");
    }

    // check messages
    for(var messageCode: messageAccessor.getMessageCodes())
    {
      assertTrue(
          expectedMessageAccessor.getMessageByCode(messageCode).isSame(messageAccessor.getMessageByCode(messageCode)),
          "Message mismatch for '" + messageCode + "'");
    }
  }


  public static void main(String[] args) throws IOException
  {
    init();
    MESSAGE_SUPPORT.exportMessages(newOutputStream(Path.of(args[0])));
  }
}
